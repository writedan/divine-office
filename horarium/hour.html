<html>
    <head>
        <title>Horarium</title>
        <script src='./suncalc.js'></script>
        <script src ='./lit-time.js'></script>
        <script src='./liturgy.js'></script>

        <!-- calendar sripts -->
        <script src = './calendar/easter.js'></script>
        <script src = './calendar/triduum.js'></script>
        <script src = './calendar/prelent.js'></script>
        <script src = './calendar/passion.js'></script>
        <script src = './calendar/lent.js'></script>
        <script src = './calendar/ascension.js'></script>
        <script src='./lit-calendar.js'></script>

        <script src='./exsurge.min.js'></script>
        <script src='./lit-engine/parser.js'></script>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <script src='./lit-engine/compiler.js'></script>
        <link rel='stylesheet' type='text/css' href='./liturgy.css'/>
        <style>
            .error {
                background-color: #f8d7da; /* Light red */
                border: 1px solid #f5c6cb; /* Darker red */
                color: #721c24; /* Dark red */
                padding: 10px 15px;
                margin-top: 20px;
                margin-bottom: 20px;
                border-radius: 5px;
            }

            table .error {
                margin-top: 0;
                margin-bottom: 0;
            }

            p {
                text-align: justify;
            }

            .instruction {
                color: red;
                font-style: italic;
            }

            table.psalm {
                border:none;
                border-collapse: collapse;
            }

            table.psalm td {
                border: none;
                border-left: 1px solid #000;
                border-right: 1px solid #000;
            }

            table.psalm td:first-child {
                border-left: none;
            }

            table.psalm td:last-child {
                border-right: none;
            }

            .title {
                text-align:center;
                font-size: 85%;
                font-weight: bold;
                grid-column: 1 / -1;
                margin-top: 20px;
            }

            .title + .title, .title ~ div .title {
                margin-top: -10;
            }

            #content {
                width: 100%;
            }

            h1,h2,h3,h4,h5,h6 {
                text-align: center;
            }

            .gabc-score {
                margin-top: -15px;
            }

            .gabc-score + .gabc-score, .gabc-score ~ div .gabc-score {
                margin-top: 20px;
            }

            .symbol {
                color: red;
            }
        </style>
    </head>
    <body>
       <div id="container">
            <div id='content-container'></div>
            <div id="content">
            </div>
        </div>
    </body>

    <script>
        annotateTemporalMetadata(tMeta)
        
        const urlParams = new URLSearchParams(window.location.search);
        let today = getLiturgicalDay(new Date(urlParams.get('date')))
        let hour = urlParams.get('hour')
        var firstVespers = false;
        if (hour == 'FirstVespers' || hour == 'FirstCompline') {
            firstVespers = true;
            hour = hour.substring(5)
            console.log("Liturgical day began at Vespers. We need yesterday's horarium.");
            today = getLiturgicalDay(advdat(new Date(urlParams.get('date')), -1))
        }
        let metadata = today.hours[hour].metadata;
        document.title = metadata.name + ' at ' + ((firstVespers && hour != 'Compline') ? 'First ' : '') + hour;

        let content = document.getElementById('content');
        let sidebar = document.getElementById('form-container');

        let h1 = document.createElement('h1');
        h1.innerHTML = metadata.name;
        h1.style.color = metadata.color;
        h1.style.letterSpacing = '1vw'
        h1.style.textTransform = 'uppercase';
        if (metadata.color == 'white') {
            h1.style.textShadow = '1px 1px 0 #000,-1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000';
        }
        content.append(h1);

        let h2 = document.createElement('h2');
        h2.innerHTML = 'At' + document.title.split(' at')[1];
        h2.style.letterSpacing = '2vw'
        h2.style.textTransform = 'uppercase';
        h2.style.color = 'red';
        content.append(h2);

        content.append(document.createElement('hr'))

        let msg = document.createElement('p');
        msg.innerHTML = 'Rendering chant. This should only take a few seconds.';
        content.appendChild(msg);

        let hourData = metadata.hours[urlParams.get('hour')]
        if (!hourData) {
            let lctx = new LiturgyContext();
            content.removeChild(msg);
            content.append(...lctx.handleError(new Error('We were unable to load the ordo. This hour/date is probably not implemented yet.')))
        }
        let lctx = new LiturgyContext(hourData.order);
        //lctx.setField('responsory', 'dummy-value')
        lctx.setField('psalter', hourData.psalter);
        for (let field of Object.keys(hourData.propers || {})) {
            lctx.setField(field, hourData.propers[field])
        }

        function resolveNode(node, idx, placeholder) {
            if (!node) {
                console.warn('Passed undefined node, these ought be filtered by now.')
                console.warn('Index', idx);
                console.warn('Placeholder', placeholder, 'will now be removed.')
                content.removeChild(placeholder)
                return;
            }

            if (!Array.isArray(node)) {
                placeholder.replaceWith(node);
                node.id = 'node-' + idx;
            } else {
                node = node.flat(Infinity).filter(n => n != undefined)
                for (let subidx in node) {
                    if (!node[subidx]) {
                        continue;
                    }

                    node[subidx].id = 'node-' + idx + '-' + subidx;
                }
                placeholder.replaceWith(...node) // we have already guaranteed all sub-promises have been resolved
            }
        }

        lctx.execute().then(result => {
            content.removeChild(msg);

            for (let idx in result) {
                let placeholder = document.createElement('div');
                placeholder.appendChild(msg.cloneNode(true));
                content.appendChild(placeholder)
                result[idx].then(r => resolveNode(r, idx, placeholder));
            }

            Promise.all(result).then(function(){
                renderAllChants();
            })
        })
    </script>

    <script>
        async function renderChant(element) {
            const FACTOR = 1.15;
            let ctx = new exsurge.ChantContext();
            let fontSize = parseFloat(window.getComputedStyle(content, null).getPropertyValue('font-size').split('px')[0]);

            let scaleFactor = (ctx.glyphScaling * fontSize * FACTOR) / ctx.textStyles.lyric.size;
            ctx.setGlyphScaling(scaleFactor);
            ctx.setFont("'Adobe Garamond Pro', 'EB Garamond', 'Crimson Text', 'Adobe Garamond Pro', 'Garamond','Georgia', serif", (fontSize * FACTOR));
            ctx.markupSymbolDictionary['^'] = 'c'
            ctx.textStyles.al.prefix = '<b>'
            ctx.textStyles.annotation.size = fontSize
            ctx.textStyles.annotation.color = 'red'

            let music = element.innerHTML.split('%%');
            let headers = GabcParser.parseHeaders(music[0]);
            let gabc = music[1].replace(/(<b>[^<]+)<sp>'(?:oe|œ)<\/sp>/g,'$1œ</b>\u0301<b>')
                .replaceAll('<sp>v</sp>', '<v>\\Vbar</v>')
                .replaceAll('<sp>r</sp>', '<v>\\Rbar</v>')
                .replaceAll('<sp>a</sp>', '<v>\\Abar</v>')
                .replaceAll('<sp>*</sp>', '<v>\\greheightstar</v>')
                .replaceAll('<sp>1</sp>', "<c>†</c>")
                .replaceAll('<sp>2</sp>', "<c>✢</c>")
                .replaceAll('<sp>+</sp>', '<v>+</v>')
                  .replaceAll(/<v>\\([VRAvra])bar<\/v>/g,'$1/.')
                  .replaceAll(/<sp>([VRAvra])\/<\/sp>\.?/g,'$1/.')
                  .replaceAll(/<b><\/b>/g,'')
                  .replaceAll(/<sp>'(?:ae|æ)<\/sp>/g,'ǽ')
                  .replaceAll(/<sp>'(?:oe|œ)<\/sp>/g,'œ́')
                  .replaceAll(/<v>\\greheightstar<\/v>/g,'*')
                  .replaceAll(/<\/?sc>/g,'%')
                  .replaceAll(/<\/?b>/g,'*')
                  .replaceAll(/<\/?i>/g,'_')
                    .replaceAll(/(\s)_([^\s*]+)_(\(\))?(\s)/g,"$1^_$2_^$3$4")
                    .replaceAll(/(\([cf][1-4]\)|\s)(\d+\.)(\s\S)/g,"$1^$2^$3");

            ctx.defaultLanguage = (headers['centering-scheme'] == 'english') ? new exsurge.English : new exsurge.Latin;

            let mappings = exsurge.Gabc.createMappingsFromSource(ctx, gabc);
            let score = new exsurge.ChantScore(ctx, mappings, headers['initial-style'] == '1');
            if (headers['initial-style'] == '1') {
                if (headers['annotation']) {
                    let a = [headers['annotation']].flat();
                    score.annotation = new exsurge.Annotations(ctx, ...a);
                }
            }

            score.updateNotations(ctx);

            element.innerHTML = '';

            score.performLayoutAsync(ctx, async function(){
                await score.layoutChantLines(ctx, content.offsetWidth, async function(){
                    let svg = await score.createSvgNode(ctx);
                    for (let e of svg.getElementsByClassName('aboveLinesText')) {
                        let offset = (((e.textContent == '~') ? 15 : 20) / (16 * 1.25)) * (fontSize * FACTOR);
                        e.setAttribute('y', parseFloat(e.getAttribute('y')) + offset)
                        if (e.textContent == '') {
                            e.textContent = '^';
                            e.style.fontWeight = 'bold';
                        }
                    }

                    element.innerHTML = '';
                    element.appendChild(svg);
                })
            })
        }

        function renderAllChants() {
            for (let chant of document.getElementsByClassName('gabc-score')) {
                chant.innerHTML = lctx.getField('score:' + chant.getAttribute('score-id')).node.directive.args[0];
                renderChant(chant);
            }
        }

        let contentWidth = content.offsetWidth;
        window.addEventListener('resize', function(event) {
            if (content.offsetWidth != contentWidth) {
                contentWidth = content.offsetWidth;
                renderAllChants();
            }
        }, true);
    </script>
</html>